---
layout: single
title: "훈련세트, 테스트세트"
categories: ML
tag: [AI, ML, Python, 데이터세트]
toc: true # 목차 설정
---

### 지도 학습(supervised learning)

- 지도 학습 알고리즘은 입력(input)과 타겟(target)으로 이루어진  
  훈련 데이터(training data)가 필요하다.
- 지도 학습은 타겟이 있으니 **알고리즘이 정답을 맞추는 것을 학습**한다.
- 새로운 데이터를 예측하는 데 활용.

### 비지도 학습(unsupervised learning)

- 타겟 없이 입력 데이터만 사용.
- 타겟을 사용하지 않으므로 **무언가를 맞힐 수는 없다**.
- BUT, **데이터를 잘 파악하거나 변형하는 데 도움**을 준다.
- i.e, 입력 데이터에서 어떤 특징을 찾는 데 주로 활용.

##### 강화 학습(reinforcement learning)

- 타깃이 아니라 알고리즘이 행동한 결과로 얻은 보상을 사용해 학습됨.

머신러닝 알고리즘의 **성능을 제대로 평가하려면** 훈련 데이터와 평가에 사용할 데이터가 각각 달라야함.

**테스트 세트**

- 평가에 사용하는 데이터
- 전체 데이터에서 20~30%를 테스트 세트로 사용하는 경우가 많음
- 전체 데이터가 아주 크면 1%만 사용해도 충분할 수 있음

**훈련 세트**

- 훈련에 사용되는 데이터
- 일반적으로 클수록 좋음

```python
# 도미 + 빙어의 길이, 무게
fish_length = [25.4, 26.3, 26.5, 29.0, 29.0, 29.7, 29.7, 30.0, 30.0, 30.7, 31.0, 31.0,
                31.5, 32.0, 32.0, 32.0, 33.0, 33.0, 33.5, 33.5, 34.0, 34.0, 34.5, 35.0,
                35.0, 35.0, 35.0, 36.0, 36.0, 37.0, 38.5, 38.5, 39.5, 41.0, 41.0, 9.8,
                10.5, 10.6, 11.0, 11.2, 11.3, 11.8, 11.8, 12.0, 12.2, 12.4, 13.0, 14.3, 15.0]
fish_weight = [242.0, 290.0, 340.0, 363.0, 430.0, 450.0, 500.0, 390.0, 450.0, 500.0, 475.0, 500.0,
                500.0, 340.0, 600.0, 600.0, 700.0, 700.0, 610.0, 650.0, 575.0, 685.0, 620.0, 680.0,
                700.0, 725.0, 720.0, 714.0, 850.0, 1000.0, 920.0, 955.0, 925.0, 975.0, 950.0, 6.7,
                7.5, 7.0, 9.7, 9.8, 8.7, 10.0, 9.9, 9.8, 12.2, 13.4, 12.2, 19.7, 19.9]
```

```python
fish_data = [[l,w] for l, w in zip(fish_length, fish_weight)]
fish_target = [1] * 35 + [0] * 14
```

이때 하나의 생선 데이터를 **샘플(sample)**이라고 부른다.

```python
from sklearn.neighbors import KNeighborsClassifier
kn = KNeighborsClassifier()
```

훈련 세트와 테스트 세트에 샘플이 골고루 섞여 있지 않으면  
샘플링이 한쪽으로 치우쳤다는 의미로 **샘플링 편향(sampling bias)**이라고 부른다.

샘플링 편향을 방지하기 위해서는 훈련 세트와 테스트 세트를나누기 전에  
데이터를 섞든지 아니면 골고루 샘플을 뽑아서 훈련 세트와 테스트 세트를 만들어야함.

**넘파이(numpy)**는 파이썬의 대표적인 배열 라이브러리.  
넘파이는 고차원 배열을 손쉽게 만들고 조작할 수 있는 간편한 도구를 많이 제공한다.

```python
# 생선 데이터를 2차원 넘파이 배열로 변환
import numpy as np

input_arr = np.array(fish_data)
target_arr = np.array(fish_target)
print(input_arr)
# 넘파이 배열 객체는 배열의 크기를 알려주는 shape 속성을 제공
print(input_arr.shape) # (샘플 수, 특성 수)
```

    [[  25.4  242. ]
     [  26.3  290. ]
     [  26.5  340. ]
     [  29.   363. ]
     [  29.   430. ]
     [  29.7  450. ]
     [  29.7  500. ]
     [  30.   390. ]
     [  30.   450. ]
     [  30.7  500. ]
     [  31.   475. ]
     [  31.   500. ]
     [  31.5  500. ]
     [  32.   340. ]
     [  32.   600. ]
     [  32.   600. ]
     [  33.   700. ]
     [  33.   700. ]
     [  33.5  610. ]
     [  33.5  650. ]
     [  34.   575. ]
     [  34.   685. ]
     [  34.5  620. ]
     [  35.   680. ]
     [  35.   700. ]
     [  35.   725. ]
     [  35.   720. ]
     [  36.   714. ]
     [  36.   850. ]
     [  37.  1000. ]
     [  38.5  920. ]
     [  38.5  955. ]
     [  39.5  925. ]
     [  41.   975. ]
     [  41.   950. ]
     [   9.8    6.7]
     [  10.5    7.5]
     [  10.6    7. ]
     [  11.     9.7]
     [  11.2    9.8]
     [  11.3    8.7]
     [  11.8   10. ]
     [  11.8    9.9]
     [  12.     9.8]
     [  12.2   12.2]
     [  12.4   13.4]
     [  13.    12.2]
     [  14.3   19.7]
     [  15.    19.9]]
    (49, 2)

```python
np.random.seed(42) # 일정한 결과를 얻기 위해
index = np.arange(49) # range랑 비슷
np.random.shuffle(index) # 섞음
print(index)
```

    [13 45 47 44 17 27 26 25 31 19 12  4 34  8  3  6 40 41 46 15  9 16 24 33
     30  0 43 32  5 29 11 36  1 21  2 37 35 23 39 10 22 18 48 20  7 42 14 28
     38]

넘파이는 슬라이싱 외에 **배열 인덱싱**이란 기능을 제공함.  
배열 인덱싱은 1개의 인덱스가 아닌 여러 개의 인덱스로 한 번에 여러 개의 원소를 선택할 수 있음.

```python
# 샘플링 편향을 방지하기 위해 데이터를 섞은 후, 훈련 세트와 테스트 세트로 나눈다.
train_input = input_arr[index[:35]] # input_arr[[13, 45, ~,38]]
train_target = target_arr[index[:35]]
test_input = input_arr[index[35:]]
test_target = target_arr[index[35:]]
```

```python
# 2차원 배열은 행과 열 인덱스를 콤마(,)로 나누어 지정.
import matplotlib.pyplot as plt

plt.scatter(train_input[:, 0], train_input[:, 1])
plt.scatter(test_input[:, 0], test_input[:, 1])
plt.xlabel('length')
plt.ylabel('weight')
plt.show()
```

![png]({{site.url}}/../../assets/images/2023-03-11-dataset/output_13_0.png)

fit() 메서드를 실행할 때마다 KNeighborsClassifier 클래스의 객체는  
이전에 학습한 모든 것을 잃어버린다. 이전 모델을 그대로 두고 싶다면 객체를 새로 만들어야함.

```python
kn = kn.fit(train_input, train_target)
kn.score(test_input, test_target)
```

    1.0

```python
print(kn.predict(test_input)) # predict 메서드가 반환하는 값은 넘파이 배열이다.
print(test_target)
```

    [0 0 1 0 1 1 1 0 1 1 0 1 1 0]
    [0 0 1 0 1 1 1 0 1 1 0 1 1 0]

사이킷런 모델의 입력과 출력은 모두 넘파이 배열이다.  
넘파이는 많은 파이썬 과학 라이브러리에 사용되는 표준 데이터!
